# M5PaperS3 Development Kit - Project Notes

## Hardware Overview
- **MCU**: ESP32-S3R8 dual-core @ 240MHz
- **Display**: 4.7" e-ink 960√ó540, 16-level grayscale, GT911 touch (2-point)
- **Memory**: 8MB PSRAM, 16MB Flash, microSD support
- **Sensors**: BMI270 gyroscope (I2C: 0x68)
- **RTC**: BM8563 (I2C: 0x51) for sleep/wake
- **Battery**: 1800mAh Li-ion, ~9.28¬µA in deep sleep
- **Extras**: Buzzer, physical button, OTG, HC1.25-4PLT peripheral port

## PlatformIO Configuration (platformio.ini)
```ini
[env:PaperS3]
platform = espressif32
board = esp32-s3-devkitm-1
framework = arduino
board_build.partitions = default_16MB.csv
board_upload.flash_size = 16MB
board_build.arduino.memory_type = qio_opi
build_flags = -DESP32S3 -DBOARD_HAS_PSRAM -DCORE_DEBUG_LEVEL=5
              -DARDUINO_USB_CDC_ON_BOOT=1 -DARDUINO_USB_MODE=1
lib_deps = epdiy=https://github.com/vroland/epdiy.git#d84d26ebebd780c4c9d4218d76fbe2727ee42b47
           M5Unified=https://github.com/m5stack/M5Unified
```

## Critical Notes
1. **PSRAM must be enabled** and set to **Octal mode** (qio_opi)
2. Requires **EPDIY library v2.0.0+**
3. **E-ink refresh**: max once every 10 seconds (evita danni hardware)
4. **SD card**: max 16GB supported
5. **Download mode**: Long-press power button until red LED flashes

## Come funziona il display E-Ink

### Tecnologia
- **Microcapsule** con particelle bianche/nere che si spostano con carica elettrica
- **Zero consumo** per immagini statiche (particelle restano in posizione senza corrente)
- **Persistenza**: immagini rimangono visibili anche a device spento
- **16 livelli di grigio** (posizioni intermedie delle particelle)

### Tipi di Refresh
1. **Full Refresh** (lento, ~2-3s):
   - Schermo lampeggia bianco‚Üínero‚Üíimmagine
   - Resetta tutte le particelle completamente
   - Elimina ghosting, massima nitidezza
   - Uso: ogni 5-10 partial refresh, o per immagini critiche

2. **Partial Refresh** (veloce, ~300-500ms):
   - Aggiorna solo pixel cambiati, no lampeggio
   - Movimento incompleto particelle ‚Üí accumula ghosting
   - Uso: UI dinamica, scroll, animazioni

### Ghosting (fantasmi)
- **Cosa**: tracce/ombre dell'immagine precedente
- **Causa**: particelle non completamente spostate nel partial refresh
- **NON √® burn-in permanente** (si risolve con full refresh)
- **Best practice**: 1 full refresh ogni 5-10 partial

### Limite "10 secondi"
- **NON significa** che immagini statiche danneggiano il display
- **Significa**: evitare refresh troppo frequenti (stress elettrodi/particelle)
- E-ink √® PERFETTO per contenuti statici (eReader, dashboard, etichette)
- **Durata display**: migliaia di refresh, ma non milioni come LCD

### Controllo Software Refresh (M5GFX + EPDIY)

**Modalit√† disponibili** (epd_mode):
1. `epd_quality` (1): Full refresh, massima qualit√† (~15 frame, 2-3s)
2. `epd_text` (2): Ottimizzato testo monocromatico (~12 frame)
3. `epd_fast` (3): Partial refresh, ghosting moderato (~8 frame, 500ms)
4. `epd_fastest` (4): Partial veloce, ghosting visibile (~5 frame, 300ms)

**NON ci sono limiti automatici hardware!** Il dev deve gestire:
- `MINIMUM_FRAME_TIME`: tempo minimo tra frame per assestamento particelle
- **Best practice**: full refresh max ogni 180s (3 min), ma dibattuto nella community
- **M5Stack suggerisce**: max 1 refresh ogni 10s per sicurezza
- **Partial refresh**: possono essere pi√π frequenti, ma ‚Üí ghosting

**Controllo manuale vs automatico**:
```cpp
// Auto display (aggiorna dopo ogni draw)
display.setAutoDisplay(true);
display.fillRect(x, y, w, h, color);  // refresh automatico

// Manuale (controllo totale)
display.setAutoDisplay(false);
display.fillRect(...);
display.fillCircle(...);
display.display();  // refresh esplicito una volta

// Gestione ghosting (responsabilit√† del dev!)
int partialCount = 0;
void smartRefresh() {
  if (partialCount >= 5) {
    display.display(epd_quality);  // full refresh
    partialCount = 0;
  } else {
    display.display(epd_fast);     // partial
    partialCount++;
  }
}
```

**Gestione temperatura**: EPDIY compensa automaticamente (~22¬∞C ottimale)
**Power management**: `epd_poweron()` prima, `epd_poweroff()` dopo refresh

## Project Structure (PlatformIO)
- `src/main.cpp` - Main application code
- `include/` - Header files
- `lib/` - Custom libraries
- `test/` - Unit tests
- `platformio.ini` - Build configuration

## Firmware Management & Launcher

### Backup Factory Firmware (PRIMA DI FLASHARE!)
```bash
# Backup completo flash (16MB per PaperS3)
esptool.py --chip esp32s3 --port /dev/tty.XXXX --baud 921600 \
  read_flash 0x0 0x1000000 factory_backup.bin

# Restore
esptool.py --chip esp32s3 --port /dev/tty.XXXX --baud 921600 \
  write_flash -z --flash_mode keep --flash_freq keep 0x0 factory_backup.bin
```

### BMorcelli Launcher - Come Funziona
**URL**: https://bmorcelli.github.io/Launcher/webflasher.html

**Architettura**:
- Launcher viene **flashato su flash interna** (partizione "test")
- File `.bin` stanno su **microSD** (non occupano flash!)
- Launcher **installa** un .bin su partizione OTA (flash interna temporanea)

**Boot Behavior**:
1. **Power-on** (accensione) ‚Üí Launcher si avvia (splash screen)
2. **Se nessun input** dopo splash ‚Üí **autostart ultimo bin installato**
3. **Se premi bottone** durante splash ‚Üí menu Launcher

**Workflow**:
```
Flash interna:           microSD:
‚îú‚îÄ Bootloader           ‚îú‚îÄ firmware1.bin
‚îú‚îÄ Launcher (test)      ‚îú‚îÄ firmware2.bin
‚îî‚îÄ OTA partition ‚Üê bin installato  ‚îî‚îÄ MMpaper.bin

Boot ‚Üí Launcher ‚Üí [timeout] ‚Üí bin installato
Boot ‚Üí Launcher ‚Üí [press btn] ‚Üí menu
```

**Installare un .bin dalla SD**:
1. Launcher menu ‚Üí naviga SD ‚Üí seleziona .bin
2. "Install" ‚Üí copia in OTA partition (flash interna)
3. Riavvio ‚Üí autostart del bin installato

**Default bin all'avvio**: S√å! Ultimo .bin installato si avvia automaticamente

**Impostazioni Launcher (menu CFG)**:
- Brightness, rotation, UI colors
- Partition scheme (per app grandi o UIFlow)
- SPIFFS backup/restore
- Filtro file: solo .bin o tutti

**SD requirements**: SDHC max 32GB (8-16GB consigliati), FAT32
**Supporto PaperS3**: v2.6.3+ (con Sprites per migliore risoluzione)

### Auto-Update da GitHub Repository

**Funzionalit√† OTA esistente in Launcher**:
- ‚úÖ Download da M5Burner repository (ufficiale)
- ‚úÖ "Favorites" custom in `config.json`:
  ```json
  "favorite": [
    {
      "name": "MMpaper",
      "fid": "",
      "link": "https://github.com/USER/MMpaper/releases/latest/download/MMpaper.bin"
    }
  ]
  ```
- ‚ùå **NON c'√® auto-check al boot** (feature mancante!)

**La tua idea: Auto-sync GitHub ‚Üí SD**
```
Boot ‚Üí WiFi ON ‚Üí Check GitHub releases ‚Üí Download nuovi .bin ‚Üí Avvia app
      ‚Üì No WiFi
      ‚îî‚îÄ‚Üí Skip check ‚Üí Avvia app
```

**Status attuale Launcher**: check manuale (menu OTA ‚Üí scegli ‚Üí download)

**Opzioni per implementare auto-update**:

**Opzione 1: Modificare Launcher** (complesso)
- Fork Launcher repository
- Aggiungere logica auto-check al boot
- Usare libreria tipo `esp_ghota` o `ESP32-OTA-Pull`
- Mantenere fork aggiornato con upstream
- **Pro**: integrato in Launcher
- **Contro**: deve ricompilare/riflashare Launcher ogni aggiornamento

**Opzione 2: Auto-update DENTRO MMpaper** (pi√π semplice!)
```cpp
// In MMpaper stesso
void setup() {
  M5.begin();

  if (WiFi.connect()) {
    if (checkGitHubUpdate()) {  // Confronta versione locale vs GitHub
      downloadUpdate();         // Download nuovo .bin su SD
      // Opzionale: installa automaticamente o notifica utente
    }
  }

  // Continua con app normale
  runMMpaper();
}
```

**Libreria usata: esp32FOTA** (Arduino-compatible)
- JSON manifest-based
- Check version automatico
- Download da GitHub raw files
- Supporta HTTPS

**Esempio implementazione in MMpaper**:
```cpp
// platformio.ini
lib_deps =
  ...
  https://github.com/Fishwaldo/esp_ghota

// main.cpp
#include <esp_ghota.h>

void setup() {
  M5.begin();

  // Check update solo se passa X ore
  if (shouldCheckUpdate()) {
    WiFi.begin(ssid, pass);
    if (WiFi.waitForConnectResult() == WL_CONNECTED) {

      esp_ghota ghota;
      ghota.setRepository("TUO_USER", "MMpaper");

      if (ghota.checkForUpdate()) {
        Serial.println("Nuova versione trovata!");
        ghota.doUpdate();  // Download & install
        ESP.restart();     // Riavvia con nuova versione
      }
    }
    WiFi.disconnect();
  }

  // App normale
  runApp();
}
```

**Vantaggi auto-update in MMpaper**:
- ‚úÖ Non serve modificare Launcher
- ‚úÖ Controllo totale su quando/come aggiornare
- ‚úÖ Pu√≤ scaricare altri .bin sulla SD (non solo se stesso)
- ‚úÖ Logica custom (es: check solo se batteria >50%)

**Workflow GitHub Releases**:
```bash
# Sviluppo locale
pio run
# Genera: .pio/build/PaperS3/firmware.bin

# Release su GitHub
gh release create v1.0.1 .pio/build/PaperS3/firmware.bin

# MMpaper sul device
Boot ‚Üí Check v1.0.1 > v1.0.0? ‚Üí Download ‚Üí Install ‚Üí Restart
```

**Conclusione**:
- Launcher attuale = NO auto-check al boot
- **Meglio**: implementa auto-update dentro MMpaper usando esp_ghota
- Cos√¨ MMpaper si aggiorna da solo + pu√≤ gestire altri .bin custom!

### Formato .bin per SD Card
PlatformIO genera automaticamente `.bin` nella cartella `.pio/build/PaperS3/`:
- `firmware.bin` - applicazione principale
- Launcher li carica e flasha al boot o tramite menu

### Dove trovare .bin per PaperS3

**M5Burner firmware location (Mac)**:
- Tasto destro su M5Burner.app ‚Üí "Mostra contenuto pacchetto"
- Path: `Contents/Resources/Packages/fw/[device]/`
- Alternativo: `M5Burner_MacOS.app/Contents/Resources/firmware/`

**GitHub Releases con .bin precompilati**:
1. **Launcher** (firmware manager): https://github.com/bmorcelli/Launcher/releases
   - Latest: v2.6.4 (Nov 2024) - supporto PaperS3 con Sprites
   - Cerca: `Launcher-M5PaperS3.bin` negli assets
2. **Factory Demo** (M5Stack official): https://github.com/m5stack/M5PaperS3-UserDemo/releases
   - Latest: v0.5 (Oct 2025)
   - Demo ufficiale per test hardware
3. **ePub Reader**: https://github.com/abirw/diy-esp32-epub-reader-m5papers3
   - Lettore ebook per PaperS3

**Community firmware**:
- M5Burner ha catalogo firmwares community (burn ‚Üí estrai .bin da app package)
- M5Stack Firmware repo: lista di firmware esterni su GitHub

## Development Status
- ‚úÖ Project initialized with PlatformIO
- ‚úÖ M5Unified, EPDIY, esp_ghota libraries configured
- ‚úÖ Auto-update da GitHub implementato in src/main.cpp
- ‚úÖ Smart refresh management (partial/full) implementato
- ‚úÖ Power management ottimizzato (IMU off, WiFi on-demand)
- ‚úÖ Config file creato (include/config.h)
- ‚úÖ README.md con istruzioni complete
- üîÑ Ready per prima compilazione quando arriva device
- ‚ö†Ô∏è Da configurare: WiFi credentials e GitHub user in config.h

## Features da Implementare in MMpaper

### üîÑ Auto-Update da GitHub (PRIORIT√Ä ALTA)
**Requisito**: MMpaper si auto-aggiorna da GitHub releases all'avvio

**Implementazione**:
- Libreria: `esp_ghota` (GitHub OTA updates)
- Check: ogni 24h (configurabile)
- Condizioni: WiFi disponibile + batteria >30%
- UI: progress su e-ink display
- Fallback: no WiFi/update ‚Üí app avvia normalmente

**Workflow utente**:
```
Boot ‚Üí [Background check GitHub] ‚Üí Update? ‚Üí Install ‚Üí Restart
                                  ‚Üì No
                                  ‚îî‚Üí Run app normalmente
```

**Config platformio.ini da aggiungere**:
```ini
lib_deps =
  ...
  https://github.com/Fishwaldo/esp_ghota
```

**Struttura codice**:
```cpp
// Versioning
#define FIRMWARE_VERSION "1.0.0"
#define GITHUB_USER "tuo_user"
#define GITHUB_REPO "MMpaper"

// Check intervals
#define UPDATE_CHECK_INTERVAL (24 * 3600 * 1000)  // 24h
#define MIN_BATTERY_PERCENT 30

void setup() {
  M5.begin();

  // 1. Check auto-update (primo step!)
  if (shouldCheckUpdate()) {
    checkGitHubAndUpdate();
  }

  // 2. Run app normale
  initializeApp();
}

bool shouldCheckUpdate() {
  // Check: timing + batteria + WiFi disponibile
}

void checkGitHubAndUpdate() {
  // Display: "Checking for updates..."
  // WiFi connect
  // esp_ghota check
  // Se update: display progress ‚Üí install ‚Üí restart
  // Se no: WiFi disconnect ‚Üí continua
}
```

**Benefits**:
- ‚úÖ Update automatici senza computer
- ‚úÖ Device sempre aggiornato in campo
- ‚úÖ Rollout graduale: release ‚Üí device si aggiornano
- ‚úÖ Nessun intervento manuale utente

## Strategia Power Management MMpaper (IMPORTANTE!)
**Default state: TUTTO SPENTO per massima batteria**

```cpp
void setup() {
  auto cfg = M5.config();
  cfg.internal_imu = false;     // üëà IMU OFF di default
  M5.begin(cfg);

  // WiFi OFF di default (gi√† spento, non serve attivar nulla)
  // Display init, ma PSU spento dopo refresh
}
```

**Attivazione moduli ON-DEMAND**:
1. **WiFi**: solo quando serve (es: aggiornamento orario, fetch dati online)
   ```cpp
   void updateOnlineData() {
     WiFi.mode(WIFI_STA);
     WiFi.begin(ssid, pass);
     // ... fetch data ...
     WiFi.disconnect(true);
     WiFi.mode(WIFI_OFF);  // üëà Spegni dopo uso!
   }
   ```

2. **IMU/Gyroscope**: solo se triggato da azione utente
   ```cpp
   void checkGesture() {
     M5.Imu.begin();
     // ... leggi movimento/gesture ...
     M5.Imu.sleep();  // üëà Torna in low power!
   }
   ```

3. **Timer/Schedule**: aggiornamenti periodici (es: ogni ora)
   ```cpp
   void loop() {
     if (hourPassed) {
       updateOnlineData();  // WiFi on ‚Üí fetch ‚Üí WiFi off
       updateDisplay();     // Display on ‚Üí refresh ‚Üí Display off
       hourPassed = false;
     }
     esp_deep_sleep(nextWakeTime);  // Sleep profondo tra aggiornamenti
   }
   ```

**Obiettivo**: settimane di autonomia con aggiornamenti orari, mesi se solo display statico

## Refresh Strategy (da implementare)
**Regola priorit√†**: Full refresh MAX ogni 10 secondi (limite hardware)
**Regola ghosting**: Full refresh ogni 5 partial (qualit√† immagine)

**Logica implementazione**:
```cpp
// Priorit√†: rispettare i 10s tra full refresh
// Se 5 partial avvengono in <10s ‚Üí tollerare pi√π partial
// Full refresh SOLO quando:
//   1. partialCount >= 5  E
//   2. sono passati almeno 10s dall'ultimo full refresh

int partialCount = 0;
unsigned long lastFullRefresh = 0;
const unsigned long FULL_REFRESH_MIN_INTERVAL = 10000; // 10s

void smartRefresh() {
  unsigned long now = millis();
  bool needs10sDelay = (now - lastFullRefresh) >= FULL_REFRESH_MIN_INTERVAL;
  bool needsGhostingFix = (partialCount >= 5);

  if (needsGhostingFix && needs10sDelay) {
    // Full refresh: entrambe condizioni soddisfatte
    display.display(epd_quality);
    lastFullRefresh = now;
    partialCount = 0;
  } else {
    // Partial refresh: o troppo presto per full, o non serve ancora
    display.display(epd_fast);
    partialCount++;
    // Se partialCount > 5 ma non sono passati 10s ‚Üí accumula ghosting temporaneo
  }
}
```

**Effetto**: ghosting temporaneo accettabile se refresh frequenti, ma hardware protetto

**Ottimizzazione ulteriore - Dirty flag**:
```cpp
// NON refreshare se non ci sono cambiamenti!
bool displayDirty = false;

void updateTemperature(float newTemp) {
  if (newTemp != lastTemp) {
    display.fillRect(x, y, w, h, WHITE);  // cancella vecchio
    display.drawString(String(newTemp), x, y);
    displayDirty = true;  // segnala cambiamento
    lastTemp = newTemp;
  }
}

void loop() {
  updateTemperature(sensor.read());

  // Refresh SOLO se ci sono stati cambiamenti
  if (displayDirty) {
    smartRefresh();
    displayDirty = false;
  }
}
```
**Vantaggio**: zero refresh inutili = batteria pi√π duratura + display pi√π longevo

## Power Management & Consumi Batteria

### Consumi misurati (PaperS3 @ 4.2V, batteria 1800mAh)
| Modalit√† | Consumo | Durata teorica | Note |
|----------|---------|----------------|------|
| **Deep sleep** | 9.28 ¬µA | ~220 giorni | Main off, gyro low power |
| **Standby** | 949.58 ¬µA | ~79 giorni | Main off, gyro on |
| **Operating** | 154.02 mA | ~11.7 ore | Main on (CPU + WiFi) |

### Moduli principali e consumi
**ESP32-S3** (main MCU):
- Active mode: ~24 mA (senza WiFi/BLE)
- WiFi attivo: +80-240 mA (a seconda uso)
- BLE attivo: +30-50 mA
- Deep sleep: ~0.01 mA
- **Di default**: WiFi/BLE OFF all'avvio (devi attivarli manualmente)

**BMI270** (giroscopio/accelerometro):
- Full operation: 685 ¬µA (~0.7 mA)
- Low power mode: 30 ¬µA
- Sleep: < 10 ¬µA
- **Di default con M5Unified**: ATTIVO all'inizializzazione!
- **Impatto**: 9.28¬µA ‚Üí 949.58¬µA se lasciato in full power

**Display E-Ink**:
- Immagine statica: 0 mA (zero consumo!)
- Durante refresh: ~150-200 mA per 2-3s
- **Strategia**: spegnere PSU dopo refresh (`epd_poweroff()`)

**WiFi** (quando attivo):
- Connection: 80-120 mA
- Data transfer: 120-240 mA
- Modem sleep (mantiene connessione): ~3 mA
- **Strategia**: usare solo quando serve, poi disattivare

### Inizializzazione ottimizzata per batteria

```cpp
#include <M5Unified.h>

void setup() {
  auto cfg = M5.config();

  // Disabilita IMU se non serve (default: enabled!)
  cfg.internal_imu = false;  // Risparmio: ~650 ¬µA

  M5.begin(cfg);

  // WiFi OFF di default (gi√† spento, ma esplicito)
  // Se serve WiFi:
  // WiFi.mode(WIFI_STA);
  // WiFi.begin(ssid, password);
  // Dopo uso: WiFi.disconnect(true); WiFi.mode(WIFI_OFF);

  // Display setup
  M5.Display.init();
}

void loop() {
  // Se usi IMU, attivalo solo quando serve
  // M5.Imu.begin();
  // ... uso ...
  // M5.Imu.sleep();  // Metti in low power quando non serve

  // Per deep sleep completo
  // prepareDeepSleep();
  // esp_deep_sleep_start();
}

void prepareDeepSleep() {
  // Spegni tutto prima del deep sleep
  M5.Imu.sleep();                    // IMU in low power
  M5.Display.sleep();                 // Display off

  // Se hai usato WiFi/BLE, spegnili esplicitamente
  esp_wifi_stop();
  esp_bt_controller_disable();
  adc_power_off();

  // Configura wakeup (es: RTC dopo N secondi, o button)
  esp_sleep_enable_timer_wakeup(60 * 1000000); // 60s
  // esp_sleep_enable_ext0_wakeup(GPIO_NUM_X, 0); // wake on button
}
```

### Best practice per massima durata batteria

**Scenario: Dashboard meteo aggiornata ogni 10 min**
```cpp
void loop() {
  // Wake up
  connectWiFi();              // 5s @ 150mA = 0.2mAh
  fetchWeatherData();         // 3s @ 150mA = 0.125mAh
  WiFi.disconnect(); WiFi.mode(WIFI_OFF);

  updateDisplay();            // 3s @ 200mA = 0.167mAh
  epd_poweroff();

  // Deep sleep per 10 min
  prepareDeepSleep();
  esp_sleep_enable_timer_wakeup(600 * 1000000); // 10 min
  esp_deep_sleep_start();     // 600s @ 0.01mA = 0.0017mAh
}
// Consumo ciclo: ~0.5mAh ogni 10 min = 72mAh/giorno
// Durata batteria: 1800mAh / 72mAh = 25 giorni! üéâ
```

**Regola d'oro**: Se un modulo non ti serve, NON attivarlo! Di default spegni tutto.

## Rendering Testo & Font su PaperS3

### Specifiche Display
- **Risoluzione**: 960√ó540 pixel @ 4.7" ‚Üí **235 PPI**
- **Confronto**: Standard e-reader (Kindle) = 300 PPI
- **Implicazione**: Font leggibili da ~12pt, ottimali 14-18pt per lettura lunga
- **16 livelli grigio**: antialiasing automatico (Bayer dithering 4x4)

### Font Built-in M5GFX
**Location**: `/M5GFX/src/lgfx/Fonts/GFXFF/`

**Famiglie disponibili**:
1. **System fonts**: Font0-Font8 (8-75px altezza)
2. **FreeMono/FreeSans/FreeSerif**: 9pt, 12pt, 18pt, 24pt (Regular, Bold, Italic, BoldItalic)
3. **Unicode**: IPA Mincho/Gothic (giapponese), efont CN/TW (cinese), efont KR (coreano)

**Esempio uso**:
```cpp
#include <M5Unified.h>

void setup() {
  M5.begin();
  M5.Display.setColorDepth(8);  // 8-bit per antialiasing grayscale

  // Font built-in
  M5.Display.setFont(&fonts::FreeSansBold18pt7b);
  M5.Display.setTextColor(TFT_BLACK, TFT_WHITE);

  // Allineamento centro schermo
  M5.Display.setTextDatum(middle_center);  // o MC_DATUM
  int x = M5.Display.width() / 2;   // 480
  int y = M5.Display.height() / 2;  // 270

  M5.Display.drawString("Hello PaperS3!", x, y);
  M5.Display.display();  // Refresh display
}
```

### Text Datum (allineamento)
```cpp
// 9 possibili allineamenti:
TL_DATUM  TC_DATUM  TR_DATUM   // Top Left/Center/Right
ML_DATUM  MC_DATUM  MR_DATUM   // Middle Left/Center/Right
BL_DATUM  BC_DATUM  BR_DATUM   // Bottom Left/Center/Right

// Esempio layout completo
M5.Display.setTextDatum(TC_DATUM);  // Top center
M5.Display.drawString("Titolo", 480, 20);

M5.Display.setTextDatum(MC_DATUM);  // Middle center
M5.Display.drawString("Contenuto", 480, 270);

M5.Display.setTextDatum(BC_DATUM);  // Bottom center
M5.Display.drawString("Footer", 480, 520);
```

### Antialiasing & Grayscale (16 livelli)
**S√å! I 16 livelli sono FONDAMENTALI per testo leggibile**

```cpp
M5.Display.setColorDepth(8);  // Abilita 8-bit grayscale

// Testo nero su bianco (classico)
M5.Display.setTextColor(TFT_BLACK, TFT_WHITE);

// Testo grigio (sfrutta 16 livelli!)
M5.Display.setTextColor(0x888888, TFT_WHITE);  // Grigio medio

// Antialiasing automatico sui bordi lettere
// M5GFX applica Bayer dithering 4x4 per smooth edges
```

**Effetto**: lettere smooth, non "pixelate", leggibili anche a 12-14pt

### Font Personalizzati

**Opzione 1: TTF da SD card** (libreria M5FontRender)
```cpp
#include <M5FontRender.h>  // DOPO M5Unified.h

M5FontRender render;
render.loadFont("/font.ttf", SD);  // Carica da microSD
render.setTextColor(TFT_BLACK);
render.setTextSize(24);
render.drawString("Custom Font!", 100, 100);
```

**Opzione 2: VLW format** (pre-convertiti)
```cpp
M5.Display.loadFont(SD, "/MyFont.vlw");
M5.Display.drawString("VLW Font", x, y);
```

**Formati supportati**: TTF (via M5FontRender), VLW, GFXFF (built-in)

### Preview in VSCode
**NON c'√® preview visivo diretto**, ma:
1. Calcola dimensioni: 960√ó540 @ 235 PPI ‚âà 10.3√ó5.8 cm
2. Usa sketch cartaceo o tool online (es: Figma, Photoshop @ 235 DPI)
3. Test rapidi: emulatore web M5Stack (limitato)
4. **Meglio**: flash & test su device reale (e-ink √® unico!)

### Font Size Recommendations (235 PPI)
| Size | Uso | Leggibilit√† |
|------|-----|-------------|
| 9-10pt | Footer, metadati | Limite minimo, strain |
| 12-14pt | Body text | OK per testo breve |
| 16-18pt | Body ideale | Ottimo per lettura lunga |
| 24pt+ | Titoli, UI | Perfetto, ben visibile |

**Nota**: 235 PPI < 300 PPI (standard eReader) ‚Üí usa font leggermente pi√π grandi

### Esempio Completo: "Hello World" App
```cpp
#include <M5Unified.h>

void setup() {
  auto cfg = M5.config();
  cfg.internal_imu = false;
  M5.begin(cfg);

  M5.Display.setColorDepth(8);
  M5.Display.fillScreen(TFT_WHITE);

  // Titolo (24pt bold)
  M5.Display.setFont(&fonts::FreeSansBold24pt7b);
  M5.Display.setTextDatum(TC_DATUM);
  M5.Display.setTextColor(TFT_BLACK);
  M5.Display.drawString("M5PaperS3", 480, 50);

  // Contenuto (18pt regular)
  M5.Display.setFont(&fonts::FreeSans18pt7b);
  M5.Display.setTextDatum(MC_DATUM);
  M5.Display.drawString("Hello World!", 480, 270);

  // Footer (12pt)
  M5.Display.setFont(&fonts::FreeSans12pt7b);
  M5.Display.setTextDatum(BC_DATUM);
  M5.Display.setTextColor(0x888888);  // Grigio
  M5.Display.drawString("Powered by MMpaper", 480, 520);

  M5.Display.display();  // Full refresh
}

void loop() {
  delay(1000);
}
```

**Output**: Testo smooth con antialiasing, leggibile, design pulito grazie ai 16 livelli grigio!
